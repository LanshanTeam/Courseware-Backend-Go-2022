## Sentinel（熔断、限流、降级）

### 为什么要用Sentinel

在我们进行系统设计时，必须要考虑系统的高性能、高并发、高可用。下面讲到的是关于高可用的三大利器：熔断、限流、降级

#### 熔断

在微服务中服务间依赖非常常见，比如评论服务依赖审核服务而审核服务又依赖反垃圾服务，当评论服务调用审核服务时，审核服务又调用反垃圾服务，而这时反垃圾服务超时了，由于审核服务依赖反垃圾服务，反垃圾服务超时导致审核服务逻辑一直等待，而这个时候评论服务又在一直调用审核服务，审核服务就有可能因为堆积了大量请求而导致服务宕机

![call-chain](.\image\call-chain.png)

由此可见，在整个调用链中，中间的某一个环节出现异常就会引起上游调用服务出现一系列的问题，甚至导致整个调用链的服务都宕机，这是非常可怕的。因此一个服务作为调用方调用另一个服务时，为了防止被调用服务出现问题进而导致调用服务出现问题，所以调用服务需要进行自我保护，而保护的常用手段就是**熔断**

##### 熔断器原理

熔断机制其实是参考了我们日常生活中的保险丝的保护机制，当电路超负荷运行时，保险丝会自动的断开，从而保证电路中的电器不受损害。而服务治理中的熔断机制，指的是在发起服务调用的时候，如果被调用方返回的错误率超过一定的阈值，那么后续将不会真正地发起请求，而是在调用方直接返回错误

在这种模式下，服务调用方为每一个调用服务(调用路径)维护一个状态机，在这个状态机中有三个状态：

- 关闭(Closed)：在这种状态下，我们需要一个计数器来记录调用失败的次数和总的请求次数，如果在某个时间窗口内，失败的失败率达到预设的阈值，则切换到断开状态，此时开启一个超时时间，当到达该时间则切换到半关闭状态，该超时时间是给了系统一次机会来修正导致调用失败的错误，以回到正常的工作状态。在关闭状态下，调用错误是基于时间的，在特定的时间间隔内会重置，这能够防止偶然错误导致熔断器进入断开状态
- 打开(Open)：在该状态下，发起请求时会立即返回错误，一般会启动一个超时计时器，当计时器超时后，状态切换到半打开状态，也可以设置一个定时器，定期的探测服务是否恢复
- 半打开(Half-Open)：在该状态下，允许应用程序一定数量的请求发往被调用服务，如果这些调用正常，那么可以认为被调用服务已经恢复正常，此时熔断器切换到关闭状态，同时需要重置计数。如果这部分仍有调用失败的情况，则认为被调用方仍然没有恢复，熔断器会切换到打开状态，然后重置计数器，半打开状态能够有效防止正在恢复中的服务被突然大量请求再次打垮

![circuit_breaker_pattern](.\image\circuit_breaker_pattern.svg)

#### 限流

限流是针对服务请求数量的一种自我保护机制，当请求数量超出服务的处理能力时，会自动丢弃新来的请求。

**为什么需要限流**

对外的API服务

- 用户增长过快
- 因为某个热点事件（微博热搜）
- 竞争对象爬虫
- 恶意的刷单

对内的RPC服务

- 一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。

**常见的限流算法**

- **计数限流算法**

  计数算法是指在一定的时间间隔里，记录请求次数，当时间间隔到期之后，就把计数清零，重新计算。如果请求次数超过统计周期内额定的最大次数时，直接拒绝访问，简单粗暴。

  计数器的值要是存在内存中就算单机限流算法，类似 Atomic 等原子类。如果存放在类似Redis的第三方缓存服务服务中就是分布式限流了，类似 Redis incr、Redis decr。

  ![img](https://img2022.cnblogs.com/blog/167509/202209/167509-20220928111942135-114072659.png)

  可能存在的问题是：请求分布的不均衡，比如在时间周期1分钟的第1秒，就把100次请求用完了，那么最后59秒都是空白的。也可能直到最后1秒才有大批量的流量

  涌入，造成系统的不稳定。

- **固定窗口限流算法（采样时间窗）**

  相对于上一个 计数限流，多了个时间窗口的概念，计数器每过一个时间窗口就重置，重新开始计算

  ![img](https://img2022.cnblogs.com/blog/167509/202209/167509-20220928115516290-1539021291.png)

  固定窗口计数算法的步骤是：

    - 将时间划分为固定的时间窗口，比如1s。
    - 在窗口时间段内，每来一个请求，对计数器加1。
    - 当计数器达到设定限制后（比如上图，限制了5s），该窗口时间内的之后的请求都被直接拒绝了。
    - 时间窗结束后，计数器重置，重新开始计数。

- **滑动窗口限流（记录每个请求到达的时间点）**

  滑动窗口限流解决固定窗口临界值的问题，可以保证在任意时间窗口内都不会超过阈值。

  相对于固定窗口，滑动窗口除了需要引入计数器之外还需要记录时间窗口内每个请求到达的时间点，因此对内存的占用会比较多。

  ![img](https://img2022.cnblogs.com/blog/167509/202209/167509-20220928123813610-1353845023.png)

  上图中每个时间窗口限流8个req，滑动窗口计数算法的步骤如下：

    - 将一个时间窗口划分为细粒度的区间，每个区间配置一个计数器，每incr一个请求则将计数+1。
    - 因为一个时间窗口是由多个时间区间组成，每走完一个区间时间后，则抛弃最老的一个区间，纳入新区间。如上图抛弃区间1，纳入新区间3
    - 窗口由t1 过渡为 窗口t2。
    - 若当前窗口的区间计数器总和超过额定的限制数量8，别区间2使用了5，则区间3最多只能使用剩下3个，后续请求都被丢弃。

  缺点：

    - 流量超过就必须抛弃或者走降级逻辑
    - 对流量控制不够精细，不能限制集中在短时间内的流量，也不能削峰填谷

- **漏桶算法（漏斗池算法）**

  类似沙漏思维，大家都用过，沙子是匀速流出得。对于漏桶来说，由于它的出水口的速度是恒定的，也就是消化处理请求的速度是恒定的，所以它可以保证组件以恒定的速率来处理请求，

  这对一些对处理速度或者资源有严格要求的系统是非常实用的。原理如下：

    - req到来则放入桶中
    - 桶内请求量满了，则拒绝后续的请求
    - 服务定速地从桶内拿出请求并处理

  宽进严出是它最大的特点，无论请求多少，请求的速率有多大，都按照固定的速率流出（定速输出），而服务也只能按照固定速率处理，有点像固定延时的消息队列。

  如果有处理不过来的请求，那就按照队列进行排队，避免巨大输出把服务搞挂掉，队列满了就refuse。

  ![0](https://img2020.cnblogs.com/blog/167509/202112/167509-20211211152909580-2112058903.jpg)

- **令牌桶算法（定速流入）**

  令牌桶和漏桶的原理类似，只不过漏桶是定速流出，令牌桶是定速流入（即往桶里塞入令牌），每个请求进来，分配一个令牌，只有拿到了令牌才能进入服务器处理，拿不到令牌的就被拒绝了。

  因为令牌桶的大小也是有限制的，所以一旦令牌桶满，后续生成的令牌就会被丢弃，拿不到令牌的服务请求就被拒绝了，达到限流的目的。执行原理如下：

    - 定速将令牌放如令牌桶
    - 当桶里面的令牌数量超过桶的额度，直接丢弃
    - 当req进来，令牌桶会分配一个令牌给请求，如果令牌桶空了，则请求会被直接拒绝

  相对于漏洞的定速流程那种的匀速消费模式，令牌桶可以将积压的令牌一下子花掉，所以在应对流量洪峰的时候，他的表现比露铜算法更优异。

  ![0](https://img2020.cnblogs.com/blog/167509/202112/167509-20211211152909597-795880084.jpg)

#### 降级

降级是通过开关配置将某些不重要的业务功能屏蔽掉，以提高服务处理能力。在大促场景中经常会对某些服务进行降级处理，大促结束之后再进行复原。

**为什么要降级**
在不影响业务核心链路的情况下，屏蔽某些不重要的业务功能，可以节省系统的处理时间，提供系统的响应能力，在服务器资源固定的前提下处理更多的请求。

### 什么是Sentinel

![Sentinel Go-毫秒级统计数据结构揭秘- 阿里巴巴中间件- 博客园](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/477384943f2f41149a267e70f9487564~tplv-k3u1fbpfcp-zoom-1.image)

[官网](https://sentinelguard.io/zh-cn/index.html) [GitHub](https://github.com/alibaba/Sentinel)

Sentinel 被称为高可用流量管理框架，分布式系统流量卫兵。假如对一个接口QPS（每秒请求数）最大限制为10000，在QPS超过10000之后的请求我们就要限制其访问，并给出友好的提示。

不限制QPS无限的次数就会造成服务器超量访问而宕机。在服务调用的过程中，如果调用链路中的某个资源出现了不稳定，比如错误数增加，请求平响升高，则大概率会导致请求堆积，进而诱发整个链路的雪崩，解决办法就是熔断、限流、降级。熔断限流就是当检测到调用链路中某个服务出现不稳定时，对服务的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。

#### 功能特性

Sentinel是分布式系统的流量防卫兵，他有如下优秀特质：

**丰富的应用场景：**

Sentinel承接了阿里近十年的双11、618等重大活动的流量核心场景，经典如秒杀、竞拍 (即突发流量控制在系统容量可以承受的范围)，消息削峰填谷，集群流量控制，实时熔断下游等应用场景

**完美的实时监控:**

Sentinel同时提供实时、丰富的监控功能，可以在控制台看到接入应用的单台机器秒级流量数据，甚至几百台规模的集群的汇总运行情况

**广泛的开源生态:**

Sentinel提供开箱即用的，可与其他框架/库的快速整合的模块,例如与SpringCloud，Dubbo，gRPC的整合，引入相应的maven依赖即可快速接入Sentinel。

**完美的SPI扩展点:**

Sentinel提供简单易用的,完美的SPI扩展接口,可以通过实现扩展接口来快速定制逻辑,例如定制规则管理,适配动态数据源等.。

## Casbin（权限控制）

[官网](https://casbin.org/zh/) [GitHub](https://github.com/casbin/casbin)

[视频教程1](https://www.bilibili.com/video/BV1qz4y167XP/) [视频教程2](https://www.bilibili.com/video/BV13r4y1M7AC/)



**参考链接**

[go-zero 熔断原理与实现](https://go-zero.dev/cn/docs/blog/governance/breaker-algorithms)

[谈谈微服务中的限流、熔断和降级](https://blog.51cto.com/u_14849432/3063052)

[微服务10：系统服务熔断、限流](https://www.cnblogs.com/wzh2010/p/13588833.html)